
# 0.1版，有關使用HTTP/3.0 QUIC的說明
## 我的很多朋友對於QUIC並不熟悉
## 1.多線覆用
傳統的 HTTP/1.1 使用單一的阻斷式連結，當前面一個Request丟失，後面的Request會全部等待在那
，甚至Client端的緩衝區被塞滿，致使效率低下，使用TCP阻斷式的單線連結，容易導致網路超時

如果，是後端跟前端的溝通，使用HTTP/1.1，在跨國連結時，這個HOL頭部阻塞的問題，就很容易引起問題，
因此大部分的跨國產品，必須在每一個國家架設多台服務器

### 何謂HOL頭部(Head of Line Blocking)阻塞? 這是早期TCP的設計問題，一個TCP連結只能做一個傳輸，
一般設計師都認為， TCP較可靠，但這個可靠是利用排隊、依照順序換來的，以下一個由時間線說明的例子可以說明其機制

| 順序 | 內容 |
| -----|------|
| t=0 | 依照順序發送a、b、c請求。|
|t=1|收到a請求，開始回應，分為封包1-5， 其中；封包3遺失。|
|t=2|收到b、c請求 準備好，但a未完成，回應但阻塞。|
|t=3|TCP檢測遺失，重傳a請求的封包3。|
|t=4|回應a封包3到達，完成|
|t=5|交付回應b與c.....如果b也有封包遺失.....|

因此，一般的API在設計救容易遇到效能低下的問題
例如:

(1)多請求情境：API 客戶端 (如移動 App 或前端) 可能在單連接上發送多個 API 呼叫 (e.g., GET /users, GET /posts, POST /comments)。如果第一個呼叫延遲 (e.g., 資料庫查詢慢)，後續呼叫會阻塞，導致整體回應時間增加。

(2)長輪詢或持續連接：某些 API 使用長輪詢 (long-polling) 來模擬即時更新，但 HTTP/1.1 的連接限制 (瀏覽器通常限 6 個並行連接) 會造成連接耗盡，間接導致阻塞。

(3)大資料傳輸：如果 API 回傳大檔案或串流數據，一個請求的阻塞會影響整個會話。

(4)性能數據：在高併發 API 中，HOL Blocking 可使平均回應時間增加 20-50% (依網絡條件而定)，尤其在微服務架構中，API 間呼叫頻繁時更明顯。

這時候，多路覆用(multiplexing)就有它的必要性

雖然，HTTP 2.0以改為多路覆用，但依然使用TCP連接，在移動網路或無線的情況下，依然容易丟包，
2.0雖然已使用多個流，但是TCP會阻塞整個連接的所有流，直到重傳完成。即使只影響一個流，
其他流也會受阻，HTTP 2.0只解決了傳送速度，壓縮頭部傳輸，但是依然沒徹底解決問題

## 2. 0-RTT連結
0-RTT (Zero Round-Trip Time，零往返時間)QUIC(Quick UDP Internet Connections) 協議中的一項關鍵功能，
旨在最小化連接建立的延遲，客戶端在不等待完整握手(handshake)完成的情況下，立即發送加密的應用數據(如HTTP請求)，
從而實現「零往返」的快速連接恢復，尤其在高延遲環境（如衛星或跨洲連接）中，能顯著加速頁面載入或數據傳輸

以往的TCP連結，需要先3次的Handshake(1-RTT)，加上TLS(約1-2個RTT)，高速的連結64ms以下，
3-RTT可能問題不大....但是如果一個RTT需要100-200ms呢?

在TLS 1.3中，允許在「恢復」先前會話時，客戶端在第一個數據包中就發送加密應用數據，而無需等待伺服器的確認。
這基於預共享金鑰(Pre-Shared Key, PSK)或會話票證(session ticket)，讓連接從「1-RTT」降到「0-RTT」

事實上，第一次連結時，是會有1-RTT的消耗，目的在於交換金鑰、加密參數以及連線ID，由於HTTP 3.0 在Header便使用加密，
因此第一次的連接，需要先交換相關參數，再往後無論是更換IP(例如，從WIFI切換到5G)，可以不斷線的無縫切換

## 完整性

QUIC使用TLS 1.3加密作為核心功能，再加上AEAD保護整體數據包，AEDA針對payload做驗證，還做了一個驗證標記，
整個措施，大致上可分為:

| 機制                      | 說明                                                                                                 |
|-------------------------|----------------------------------------------------------------------------------------------------|
|地址驗證(Address Validation)| 使用integrity-protected tokens(至少128位entropy)在Retry和NEW_TOKEN frames中，防止放大攻擊和偽造。Token被AEAD保護，客戶端無法修改 |
|Stateless Reset Tokens| 難以猜測，使用偽隨機函數和靜態金鑰生成，確保重置請求的完整性                                                                     |
|Packet Number Spaces| 分為Initial、Handshake和Application Data空間，每空間從0開始遞增，防止跨加密級別的重放                                        |
|Connection ID驗證| 握手期間的Connection ID被包含在transport parameters中驗證，防止中間人篡改                                              |
|0-RTT 的特殊處理| 0-RTT數據有重放風險(replay vulnerability)，因此只允許idempotent操作(如GET)，並需事先配置防重放機制|
|整體防護|如果數據包與連接狀態不一致(e.g.,保護移除失敗)，則丟棄|

相較原本的TCP/TLS，QUIC的完整性更強大，因為內建於協議中，減少中間層攻擊；支援連接遷移而不損完整性。

## 普遍度

本來以為，Nginx在2024年底才支持HTTP 3.0，使用這個技術的企業應該很少，事實上...
Youtube、Instagram、Facebook、微信、Tiktok、Bilibili等等，都已經全面使用HTTP 3.0了，
所以這已經是一個很普遍的技術了，只是大企業不講，讓不用功的小企業永遠落後...

至於，開發方面，以Rust及Go的支援最完整，Python與PHP是透過Nginx來達到效果...
大概就是JAVA、C#、Ruby是不支援的，基本上在設計開發上支援不是大問題
